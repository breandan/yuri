import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.jetbrains.kotlin.renderer.KeywordStringsGenerated.KEYWORDS

plugins {
  kotlin("jvm") version "1.2.60"
  idea apply true
  application
  id("com.gradle.plugin-publish") version "0.10.0"
  `java-gradle-plugin`
}

group = "co.ndan"
version = "0.1-SNAPSHOT"

repositories {
  mavenCentral()
}

application {
  mainClassName = "main/kotlin/HelloYuriKt"
}

dependencies {
  compile(kotlin("stdlib-jdk8"))
  //TODO: Add project proper source code generation
//    compile("com.squareup:kotlinpoet:1.0.0-RC1")
}

val genSources by tasks.creating(Task::class.java) {
  generateProjectSources()
}

tasks.withType<KotlinCompile> {
  dependsOn(genSources)
  kotlinOptions.jvmTarget = "1.8"
}

gradlePlugin {
  (plugins) {
    "yuri" {
      id = "co.ndan.yuri"
      implementationClass = "co.ndan.yuri.Yuri"
    }
  }
}

pluginBundle {
  website = "http://www.gradle.org/"
  vcsUrl = "https://github.com/breandan/yuri"

  description = "A type-safe URI builder for Kotlin."

  (plugins) {
    "yuri" {
      displayName = "Yuri"
      tags = listOf("uri", "type-safe", "codegen", "kotlin")
      version = "0.1"
    }
  }

  mavenCoordinates {
    groupId = "co.ndan"
    artifactId = "yuri"
    version = "0.1"
  }
}

// TODO: Figure out why this doesn't work
idea {
  module {
    generatedSourceDirs.add(File("build/generated/source/yuri/main"))
    sourceDirs.add(File("build/generated/source/yuri/main"))
  }
}

fun generateProjectSources() {
  val walker = File(".").walkTopDown()
  val allFiles = walker
      .maxDepth(3)
      .filter { !it.path.contains(".git") }
      .filter { file -> !file.path.toCharArray().any { it.isDigit() } }
  val topLevelFiles = walker
      .maxDepth(1)
      .filter { !it.path.contains(".git") }
  val topLevelFileNames = topLevelFiles
      .map { it.name.replace(".", "_dot_").replace("$", "_dollar_")}
  val allFileNames = allFiles
      .map {
        it.name.replace(".", "_dot_")
            .replace("-", "_dash_")
            .replace("$", "_dollar_")
      }
      .map { if (it in (KEYWORDS + "out")) "`$it`" else it }
      .toSet()

  val secondLevelFiles = allFiles.filter { it !in topLevelFiles }

  val header = """// This file was generated by Yuri, a type-safe URI builder for Kotlin.
    package main.kotlin
    import main.kotlin.G.*
    import java.io.File

    private const val unused = "UNUSED_PARAMETER"

    abstract class G private constructor(val uri: String) {
    @Yuri object project_: G("/") {""".trimIndent()

  var generatedFile = header
  topLevelFileNames.forEach {
    generatedFile += "\n@JvmName(\"$it\") operator fun div(@Suppress(unused) a: $it.Companion) = $it<project_>(\"\")\n"
  }

  generatedFile += """
    override fun toString() = uri
  }
  """.trimIndent()

  allFileNames.forEach {
    generatedFile += "\nopen class $it<T>(uri: String): G(uri) { companion object }\n"
  }

  generatedFile += "override fun toString() = \"\$uri/\${javaClass.simpleName}\"\n companion object {\n    fun uri(g: G) = File(\"\$g\")\n}\n}"
  val dirMap = secondLevelFiles
      .map { file ->
        val elements = file.path
            .replace("-", "_dash_")
            .substring(2)
            .replace(".", "_dot_")
            .replace("$", "_dollar_")
            .split("/")
            .map { if (it in (KEYWORDS + "out")) "`$it`" else it }
            .asReversed()

        val value = elements.first()
        val key = elements.drop(1).joinToString("<") + "<project_>" + ">".repeat(elements.size - 2)

        Pair(key, value)
      }

  var jvmName = 1
  dirMap.forEach {
    jvmName++
    generatedFile += "@JvmName(\"$jvmName\") operator fun <S: ${it.first}> S.div(@Suppress(unused) a: ${it.second}.Companion) = ${it.second}<S>(\"\$this\")\n"
  }

  File("src/main/kotlin/G.kt").apply { this.createNewFile() }.writeText(generatedFile)

  File("build/generated/source/yuri/main/").apply { mkdirs() }
  File("build/generated/source/yuri/main/G.kt").apply { createNewFile() }.writeText(generatedFile)
}